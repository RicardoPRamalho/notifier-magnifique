/*
 * Copyright 2013 Thiago Uriel M. Garcia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.uriel.nm.server.business.datamodel;

import io.uriel.nm.server.business.model.Device;
import io.uriel.nm.server.business.repository.IDeviceRepository;

import java.util.List;
import java.util.Map;

import org.primefaces.model.LazyDataModel;
import org.primefaces.model.SelectableDataModel;
import org.primefaces.model.SortOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.stereotype.Component;

/**
 * Data model used to allow extended functionality to subscription table UI.
 * <p>
 * Since this object is provided by SpringFramework, it's wrapped data won't
 * be defined via constructor, which is a common way.
 * <p>
 * To define the wrapped data, receive an instance for this object, by Spring's
 * regular Dependency Injection system, and call the public method from base
 * class - {@code setWrappedData}.
 * 
 * @author Thiago Uriel M. Garcia
 */
@Component
public class SubscriptionDataModel extends LazyDataModel<Device>
implements SelectableDataModel<Device>
{
    /** Serialization constant, generated by JVM. */
    private static final long serialVersionUID = -9047352486741679563L;

    /** Subscription services, exposed to this Data Model. */
    @Autowired
    private IDeviceRepository repository;

    /** {@inheritDoc} */
    @Override  
    public List<Device> load(int first, int pageSize, String sortField, SortOrder sortOrder, Map<String, String> filters) 
    {
        //
        // Verify incoming direction from Primefaces and convert it to Spring Data.
        // This login tells that when Prime requires a "descending order", then we
        // must explicitly create a Spring descending order. If Prime requires an
        // "ascending order" or "no order", we relate it to Spring's ascending order.
        //
        // Another conversion that must be done is the Primefaces' first ELEMENT to
        // Spring data's first PAGE. For that, we use: first/pageSize.
        //
        final Direction direction = sortOrder.equals(SortOrder.DESCENDING) ? Direction.DESC : Direction.ASC;
        final Sort sort = createSortDirective(direction, sortField);
        final PageRequest pageAndSort = new PageRequest(first/pageSize, pageSize, sort);
        return ((PageImpl<Device>) repository.findAll(pageAndSort)).getContent();
    }
    
    /** {@inheritDoc} */
    @Override
    public Device getRowData(String rowKey) 
    {
        return repository.findOne(rowKey);
    }

    /** {@inheritDoc} */
    @Override
    public Object getRowKey(Device device) 
    {
        return device.getDeviceId();
    }
    
    /** {@inheritDoc} */
    @Override
    public int getRowCount() 
    {
        long count = repository.count();
        if (count < Integer.MIN_VALUE || count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Long is too big to be cast to an int.");
        }
        return (int) count;
    }
    
    /**
     * Creates a sort directive.
     * <p>
     * If parameter {@code sortField} equals the device's platform, then it will
     * create a composite sort, that will also consider device's O/S version.
     * <p>
     * Otherwise, it will create a regular sort, literal to incoming parameters.
     * 
     * @param direction {@code Direction} used to sort.
     * @param sortField {@code String} that is the column reference.
     * 
     * @return
     *      {@code Sort} object, created by the definition presented above.
     */
    private static Sort createSortDirective(Direction direction, String sortField)
    {
        if ("osName".equalsIgnoreCase(sortField))
        {
            final Order osNameOrder = new Order(direction, "osName");
            final Order osVersionOrder = new Order(direction, "osVersion");
            final Sort sort = new Sort(osNameOrder, osVersionOrder);
            return sort;
        }
        else
        {
            final Sort sort = new Sort(new Order(direction, sortField));
            return sort;
        }
    }
}
